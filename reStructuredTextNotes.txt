reStructuredText is the defualt plaintext markup language used by Sphinx.

Paragraphs;
  The paragraph (ref) is the most bsic block in a reST document. Paragraphs are simply chunks of text separated by one more blank lines. Indentation is significant in reST, so all lines of the same paragraph must be left-aligned to the same level of indentation.

Inline markup:
  One asterisk: *text* for emphasis (italics).
  Two asterisk: **text** for strong emphasis (boldface)
  Backquotes: ``text`` for code samples

  If asterisks and backquotes appear in running text and could be confused with inline markup delimiters, they have to be escaped with a backslash.

  **What is running text in Sphinx?**

  Inline mark restrictions
    It may not be nested
    The content may not start or end with whitespace: * text* is wrong.
    it must be separated from surrounding text by non-word characters. Use a backslash escaped space to work around that: thisis\ *one*\ word.

List and Quote-link blocks
  An asterisk at the start of a paragraph and indent properly.
  The same goes for numbered lists; they can also be autonumbered using a # sign

  * This is a bulleted list.
  * It has two items, the second
    item uses two lines

  1. This is a numbered list.
  2. It has two items too.

  #. This is a numbered list.
  #. it has two items too.

  Nested lists are possible, but b aware that they must be separated from the parent list items by blank lines:

  * this is
  * a list

    * with a nested list
    * and some subitems

  * and here the parent list continues

  Definition list are created as follows:
    term (up to a line of text)
      Definition of the term, whihc must be indented

      and can even consist of multiple paragraphs

    next term
      Description.

      Note that the term cannot have more than one line of text.

      Quoted paragraphs (ref) are created by just indenting them more than the surrounding paragraphs.

      Line blocks (ref) are a way of preserveing line breaks:

        | These lines are
        | broken exactly like in
        | the source file

List blocks
  Literal code blocks are introduced by ending a paragraph with the special marker ::. The literal block must be indented (and, like all paragraphs, separated from the surrounding ones by blank lines):
    This is a normal text paragraph. The next paragraph is a code sample::

    It is not processed in any way, except
    that the indentation is removed.

    It can span multiple lines.

  The handling of the :: marker is smart:
    If it occurs as a paragraph of its own, that paragraph is completely left out of the document.
    If it is preceded by whiespace, the marker is removed.
    If it is preceded by non-whitespace, the marker is replaced by a single colon.

Code highlighting can be enabled for these literal blocks on a document-wide basis using the highlight directive and on a project-wide basis using the highlight_language configuration option.

The code-block directive can be used to set highlighing on a block-by-block basis.

Tables
  For grid tables, you have to "paint" the scell grid yourself. 

  Simple tables are easier to write, but limited: they must contain more than one row, and the first column cells cannot contain multiple lines.
    They look like this:
    ===== ===== =======
    A     B     A and B
    ===== ===== =======
    False False False
    True  False False
    False True  False
    True  True  True
    ===== ===== =======

  Two more syntaxes are supported: CSV tables and list tables. They use an explicit markup block.

Hyperlinks
  External links
    Use `Link text <https://domain.invalid/>`_ for inline web links. If the link text should be the web address, you don't need special markup at all, the parser finds links and mail addresses in ordinary text.
    There must be a space between the link text and the opening < for the URL.
    You can also separate the link and the target definition, like this:
      This is a paragraph that contains `a link`_
      .. _a link: https://domain.invalid/
  Internal links
    Internal linking is done via a special reST role provided by Sphinx.

Sections
  Section headers are created by underlining (and optionally overlining) the section title with a punctuation character, at least as long as the text:
    =================
    This is a heading
    =================
    Normally, there are no heading levels assigned to certain characters as the structure is determined from the succession of headings. However, this convention is used in Python's Style Guide for documenting which may follow:
      # with overline, for parts
      * with overline, for chapters
      = for sections
      - for subsections
      ^ for subsubsections
      " for paragraphs
Field Lists
  Fields list are sequences of fields marked up like this:
    :fieldname: Field content
      They are commonly used in Python documentation:
        def my_function(my_arg, my_other_arg):
          """A function just for me.

          :param my_arg: The first of my arguments.
          :param my_other_arg: The second of my arguments.

          :returns: A message (just for me, of course)

Roles
  A role or "custom interpreted text role" is an inline piece of explicit markup It signifies that the enclosed text should be interpreted in a specific way. Sphinx uses this to provide semantic markup and cross-referencing of identifiers, as described in the appropriate section. The general syntax is :rolename:`content`.

  Docutils supports the following roles:
    emphasis - equivalent of *emphasis*
    strong - equivalent of **strong**
    literal - equivalent of ``literal``
    subscript - subscript text
    superscript - superscript text
    title-reference - for titles of books, periodicals, and other materials

Explicit Markup
  Explicit markup is used in reST for most constructs that need special handling, such as footnotes, specially-highlighted paragraphs, comments, and generic directives.

  An explicit markup block begins with a line starting with .. followed by whitespace and is terminated by the next paragraph at the same level of indentation. (There needs to be a blank line between explicit markup and normal paragraphs. This may all sound a bit complicated, but it is intuitive enough when you write it.)

Directives
  A directive is a generic block of explicit markup. Along with roles, it is one of the extension mechanisms of reST, and Sphinx makes heavy use of it.

  Docutils supports the following directives:
    Admonitions: attention, caution, danger, error, hint, important, note, tip, warrning and the generic adonition
    Images: 
      image
      figure (an image with caption and optional legend)
    Additional body elements
      contents (a local, i.e. for current file only, table of contents)
      container (a container with a custom class, useful to generate an outer <div> in HTML)
      rubric (a heading without relation to the document sectioning)
      topic, sidebar (special highlighted body elements)
      parsed-literal (literal block that supports inline markup)
      epigraph (a block quote with optional attribution line)
      highlights, pull-quote (block qotes with their own class attribute)
      compound (a compound paragraph)
    Special tables
      table (a table with title)
      csv-table (a table generated from comma-separated values)
      list-table (a table generated from a list of lists)
    Special directives
      raw (include raw target-format markup)
      include (include reStructuredText from another file) - in Spinx, when given an absolute include file path, this directive takes it as relative to the source directory
      class (assign a class attribute to the next element)
    HTML specifics:
      meta (generation of HTML <meta> tags)
      title (override documemt title)
    Influencing markup:
      default-role (set a new default role)
      role (create a new role)

    Do not use the directives sectnum, header and footer.

    Basically, a directive consists of a name, arguments, options and content. Looking at this example:
    .. function:: foo(x)
                  foo(y, z)
       :module: some.module.name

       Return a line of text input from the user

    function is the directive name. It is given two arguments here, the remainder of the first line and the second line, as well as one option module (as you can see, options are given in the lines immediately following the arugments and indicated by the colons). Options must be indented to the same level as the directive content.
    The directive content follows after a blank line and is indented relative to the directive start or if options are present, by the same amount as the options.

    .. code-block::
       :caption: A cool example

        The output of this line starts with four spaces.

    .. code-block::

        The output of this line has no spaces at the beginning.

    In the first code block, the indent for the content was fixated by the option line to three spaces, consequentlly the content starts with four spaces. In the latter the indent was fixed by the content itself to seven spaces, thus it does not start with a space.

Images
  reST supports an image directive
    .. image:: gnu.png
       (options)

      When used  within Sphinx, the file name given (here gnu.png) must either be relative to the source file, or absolute which menas that they are relative to the top source directory. For example, the file sketch/spam.rst could refer to the image images/spam.png as ../images/spam.png or /images/spam.png.

    Sphinx will automatically copy iamge files over to a subdirectory of the output directory on building (e.g. the _static directory for HTML output.)
    
Footnotes
  For footnotes, use [#name]_ to mark the footnote location, and the footnote body at the bottom of the document after a "Footnotes" rubric heading, like so:

  Lorem ipsum [#f1] dolor sit amet ... [#f2]_
  .. rubic:: Footnotes

  .. [#f1] Text of the first footnore.
  .. [#f2] Text of the second footnote.

  You can also explicitly number the footnotes ([1]_) or use auto-numbered footnotes without names ([#]_).

Citations
  Standard reST citations are supported, with the additional feature that they are "global", i.e. all citations can be referenced from all files. Use them like so:

  Lorem ipsum [Ref]_ dolor sit amet.

  .. [Ref] Book or article reference, URL or whatever.

    Citation usage is similar to footnote usage, but with a label that is not numeric or begins with #.

Substitutions
  reST supports "substitutions", which are pieces of text and/or markup referred to in the text by |name|. They are defined like footnotes with explicit markup blocks, ike this:
  .. |name| replace:: replacemnt *text*

    or this:
  .. |caution| image:: warning.png
               :alt: Warning!

  If you want to use some substitutions or all documents, put them into rst_prolog or rst_epilog or put them into a separate file and include it into all documents you want to use them in, using the include directive.

Comments
  Every explicit markup block which isn't a valid markup constructs (like the footnotes above) is regarded as a comment. For example:
  .. This is a comment.
    You can indent text after a comment start to form multline comments:
  ..
    This whole indented block
    is a comment.

HTML Metadata
  The meta directive allows specifying the HTML metadata element of a Sphinx documentation page. For example, the directive:
    .. meta::
      :description: The Sphinx documentation builder
      :keywords: Sphinx, documentation, builder

      will generate the following HMTL output:

        <meta name="desription" content="The Sphinx documentation builder"
        <meta name="keywords" content="Sphinx, documentation, builder"

  Also, Sphinx will add the keywords as specified in the meta directive to the search index. Thereby, the lang attribute of the meta element is considered. For example the directive:

    .. meta::
      :keywords: backup
      :keywords lang=en: pleasefindthiskey pleasefindthiskeytoo
      :keywords lang=de: bittediesenkeyfinden

    adds  the following words to the search indices of builds with different language configurations:
      pleasefindthiskey, pleasefindthiskeytoo to English builds
      bittediesenkeyfinden to German builds
      backup to builds in all languages

Source encoding
  Since the easiest way to include special characters like em dashes or copyright signs in reST is to directly write them as Unicode characters, one has to specify an encoding. Sphinx assumes source file sto be encoded in UTF-8 by default; you can change this with the source_encoding config value.

Gotchas
  There are some problems one commonly runs into while authoring reST documents:
    Separation of inline markup: As said above, inline markup spans must be separated from the surrounding text by non-word characters, you have to use a backslash-escaped space to get around that.
    No nested inline markup: Something like *see :func:`foo`* is not possible
